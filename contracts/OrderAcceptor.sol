// SPDX-License-Identifier: MIT

pragma solidity ^0.8.7 || ^0.7.6;


import "@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol";
import "@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol";
import "@chainlink/contracts/src/v0.8/interfaces/AutomationCompatibleInterface.sol";
import "hardhat/console.sol";
import "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol";
import "contracts/IOrderSwapper.sol";

/**
 * 1. Save limit order params
 * 2. Approve and transfer money to contract
 * 3. Keep checking price until matched
 * 4. Execute swap on uni
 */
contract OrderAcceptor is AutomationCompatibleInterface {

    struct EthOrder {
        uint256 id;
        uint256 amount;
        uint256 price;
    }

    /**
     * Use an interval in seconds and a timestamp to slow execution of Upkeep
     */
    uint256 public immutable interval;
    uint256 public lastTimeStamp;
    EthOrder[] public orders;
    uint256 internal orderCount = 0;
    AggregatorV3Interface internal immutable priceFeed;
    IOrderSwapper internal immutable orderSwapper;

    constructor(uint _interval, address _priceFeed, address _swapper) {
        interval = _interval;
        lastTimeStamp = block.timestamp;
        priceFeed = AggregatorV3Interface(_priceFeed);
        orderSwapper = IOrderSwapper(_swapper);
    }

    function acceptEthOrder(uint256 _amountEth, uint256 _price) external returns (uint256) {
        orderCount++;
        orders.push(EthOrder({ id: orderCount, amount: _amountEth, price: (1e18 / _price) }));
        return orderCount;
    }

    function getAllOrders() public view returns (EthOrder[] memory allOrders) {
        return orders;
    }

    function checkUpkeep(
        bytes memory /* checkData */
    )
        public
        view
        override
        returns (
            bool upkeepNeeded,
            bytes memory /* performData */
        )
    {
        upkeepNeeded = (block.timestamp - lastTimeStamp) > interval;
        // We don't use the checkData in this example. The checkData is defined when the Upkeep was registered.
    }

    function performUpkeep(
        bytes calldata /* performData */
    ) external override {
        //We highly recommend revalidating the upkeep in the performUpkeep function
        (bool upkeepNeeded, ) = checkUpkeep("");
        require(upkeepNeeded, "Time interval not met");
        lastTimeStamp = block.timestamp;
        executeAllMatchedOrders();
        // We don't use the performData in this example. The performData is generated by the Automation Node's call to your checkUpkeep function
    }
    
    function executeAllMatchedOrders() internal {
        (
            uint80 roundID,
            int256 price,
            uint256 startedAt,
            uint256 timeStamp,
            uint80 answeredInRound
        ) = priceFeed.latestRoundData();
        uint256 currentPrice = uint256(price);
        console.log(currentPrice);
        uint256 size = orders.length;
        for (uint16 i = 0; i < size; i++) {
            EthOrder memory next = orders[i];
            // we have priceFeed of DAI/ETH so comparison is reverted
            if (next.price < currentPrice) {
                executeSell(next);
            }
        }
    }

    function executeSell(EthOrder memory order) internal {
        orderSwapper.performSwapForDAI(order.id);
    }
}